%************************************************
\chapter{Introduction}\label{ch:introduction}
%************************************************
\section{An alternative user interface}
In this thesis we will investigate how we can create a user interface which allows us to execute queries in a query language by expressing instructions in natural language. In other terms, we want to translate from a natural language into a query language. A query language is a computer language which is used to query a database or index. A natural language is a language that humans use to communicate with each other.

\section{Problem description}
How can one retrieve information from a computer by writing instructions in a natural language? The inspiration for this thesis came from Facebook graph search\footnote{https://www.facebook.com/about/graphsearch}, which is a service that allows users to search for entities by asking the server for information in a natural language.

In this project, we have chosen examine how a similar service can be realized. We have limited the project to handle questions that can occur naturally in the intranet of a software development company. We assume that there exists an intranet which consists of a database with information about employees, customers and projects. A typical question to ask in this environment could be

\begin{minted}{csharp}
Which people know Java?
\end{minted}

The answer would be a list of all employees in the database who have some degree of expertise of the programming language \textsc{Java}. However, when using search engines, expert users do not ask questions as the one above. The simply rely purely on keywords. The following question is more suited for expert users

\begin{minted}{csharp}
people know java
\end{minted}

How can we create a user interface that is sufficient for both regular- and expert users? And how can we translate these questions into machine readable queries?

\section{A proposed solution}
Query languages require precise syntax, we therefore need precise translation from a natural language into a query language. Since we have a limited scope of questions, we know all questions that can be asked - and we know how their machine readable representation shall look like. We only need a tool which we can use to make the mapping between natural language into query language. A very flexible tool we can use to accomplish this is a multilingual grammar. 

A grammar is a set of structural rules which decide how words can can be created and be combined into clauses and phrases. By expressing \emph{how} words can be combined into a question in one language one can also use the same logic to express how the same question can be produced in another language. A \emph{multilingual} grammar is a special type of grammar which can translate between two or more languages.

Grammars has been used since the 1950's in the field of computer science \cite[p. 4]{ranta:2011}, and they have played a main role in the development of compilers where they are used to translate source code into machine readable instructions.

\section{Grammatical Framework}
Grammatical framework (GF) is a functional programming language for creating grammars for natural languages.\cite[p. 1]{ranta:2011} GF features a strong type system, separate abstract and concrete syntax rules and reusable libraries to facilitate design of grammars. For a reader with a background within compilers, one can easily see that GF is very much based on the theory of programming languages. GF adopts the use of abstract and concrete syntax in the same sense as in compiler theory. 

Abstract syntax is a tree representation which captures the \emph{meaning} of a sentence, and leaves out anything irrelevant. The concrete syntax represents a natural language. It describes how an abstract syntax tree is represented as a string in the natural language.

With both abstract and concrete syntaxes, GF is able to create a \emph{parser} and a \emph{linearizer} for all given concrete languages. The parser translates strings into abstract syntax and the linearizer transaltes abstract syntax tree's into string representations for a specified concrete syntax. In addition, GF can also derive a \emph{generator} for the abstract syntax. The generator can create all possible abstract syntax trees.

Because GF separates abstract and concrete syntax, one can easily add a new concrete syntax (natural language) to an existing abstract syntax. This advantage also makes it easy to translate between many languages.

\subsection{A simple example}
The following section presents an example of how GF can be used to create a grammar that can generate and translate the sentence \emph{which people know Java?} into Apache Solr query language and vice verca.\marginpar{Apache Solr is a search platform based on Apache Lucene. We will explain more about Solr query language later in the thesis.}

\subsubsection*{Abstract syntax}
To model the meaning of sentences, GF adopts the use of functions and \emph{categories}. A category (\emph{cat}) in GF is the same as a data type. We start by listing the categories we need. We then define how our data types can take on values. This is achieved by using functions. The functions in an abstract syntax are not implemented, we can therefore only see the function declarations. The purpose for this is to allow the concrete syntaxes to choose how to represent the semantics. Two concrete syntaxes can therefore implement the same semantics differently.

We define a function \texttt{Java : Object} which means that \texttt{Java} is a constant \marginpar{A function without arguments is called a constant in functional programming languages.} and returns a value of type \texttt{Object}. \texttt{Know} takes one argument of the type \texttt{Object} and returns a value of type \texttt{Relation}.

A question can be created by obtaining a value of the type \texttt{Question}. Only \texttt{MkQuestion} returns the desired type and it takes two arguments, one of type \texttt{Subject} the other of type \texttt{Relation}.

\captionsetup[figure]{font=small,skip=-5pt}
\begin{figure}[h]
\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm,
               baselinestretch=1,
               fontsize=\footnotesize]{c}
  abstract Questions = { 
    flags startcat = Question; 
    cat
      Question ; -- A question
      Subject ;  -- The subject of a question
      Relation ; -- A verb phrase
      Object ;   -- an object
	
    fun		 	  
      MkQuestion : Subject -> Relation -> Question ;
      People : Subject ;
      Know : Object -> Relation ;
      Java : Object ; 
  }
\end{minted}
\caption{Abstract syntax}
\end{figure}

We can now use this abstract syntax to create an abstract syntax tree as seen in figure 2.

\begin{figure}[h]
\begin{minted}[mathescape,
               frame=lines,
               framesep=2mm,
               baselinestretch=1,
               fontsize=\footnotesize]{c}
  MkQuestion People (Know Java)
\end{minted}
\caption{Abstract syntax tree}
\end{figure}

\subsubsection*{Concrete syntax}

We are now going to implement the function declarations we just defined in the abstract syntax. This implementation makes it possible to linearize abstract syntax trees into concrete syntax. We will start by defining the concrete syntax for English.

\subsubsection*{English concrete syntax}

Figure 2 shows the implementation of the concrete syntax for English. Categories are linearized by the keyword \emph{lincat}. Here we assign all categories to be strings. The functions are linearized by using the keyword \emph{lin}. We linearize \texttt{Java} by returning the string \texttt{"Java"}, as it is a constant function. Analogously, \texttt{"people"} is returned by \texttt{People}. The function \texttt{Know} takes one parameter. This parameter is appended on the string \texttt{"know"}. Finally, \texttt{MkQuestion} takes two arguments, where \texttt{subject} is prepended and \texttt{relation} is appended on \texttt{"who"}. One can easily see how these functions can be used to construct the sentence \emph{people who know Java}. This sentence is different from the previously discussed question \emph{which people know Java?} The reason why we chose to model the former is because we find that it is more natural tell the computer what we want rather than ask it politely.

\newenvironment{myfont}{\myfont}{\par}

\begin{figure}[h]
\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm,
               baselinestretch=1,
               fontsize=\footnotesize]{c}
  concrete QuestionsEng of Questions = {
    lincat
      Question = Str ;
      Subject = Str ;
      Relation = Str ;
      Object = Str ;
    lin
      MkQuestion subject relation = subject ++ "who" ++ relation ;
      People = "people" ;
      Know object = "know" ++ object ;
      Java = "Java" ;
  }
\end{minted}
\caption{English concrete syntax}
\end{figure}

\subsubsection*{Solr concrete syntax}

The final step in this example is to linearize abstract syntax into Solr concrete syntax.
  As figure 4 shows, the categories are strings as in English. The function linearizations are however
  different. \texttt{People} returns 
  \texttt{"object\_type : Person"}, we assume that 
  the Solr-schema has a field with the name \texttt{object\_type} which represents 
  which type a document is. Similarly, we make another assumption about \texttt{Know}. \texttt{MkQuestion} is also implemented differently, here we can see that the result is going to be a query string\footnote{http://en.wikipedia.org/wiki/Query\_string} by looking at the first part \texttt{"q="} which is prepended on the subject. We then append \texttt{"AND"} together with \texttt{relation} in order to create a valid Solr query.

\begin{figure}[h]
\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm,
               baselinestretch=1,
               fontsize=\footnotesize]{c}
  concrete QuestionsSolr of Questions = {
    lincat
      Question = Str ;
      Subject = Str ;
      Relation = Str ;
      Object = Str ;

    lin
      MkQuestion subject relation = "q=" ++ subject ++ "AND" ++ relation ;
      People = "object_type : Person" ;
      Know object = "expertise : " ++ object ;
      Java = "Java" ;
  }
\end{minted}
\caption{Solr concrete syntax}
\end{figure}

\subsubsection*{Translation}

\section{GF resource grammar library}

The previous example is fairly easy to understand, but it is also very small. As a grammar grows to support translation of more sentences, the complexity grows as well. GF has the power to make distinctions between singular and plural forms, genders, tenses and anteriors. However, in order to correctly develop a grammar to translate these sentences one needs to have knowledge of linguistics. It is also very time consuming to implement basic morphologies over and over again. Instead, one can use GF resource grammar library (RGL). The RGL contains at the time of writing grammars for 29 natural languages. These grammars includes categories and functions which can be used to represent all kinds of different words and sentences. A developer needs therefore only knowledge of her \emph{domain} and do not need to worry about linguistic problems. By domain, we mean specific words which may have special grammatical rules, e.g. fish in English which is the same in singular as in plural form.

\subsection{Example usage of RGL in a grammar}

In this section, we will present how the previous concrete syntax for English can be implemented by using the RGL. We will also show how this grammar can be further generalized into an incomplete grammar which can be used by both English and Swedish.

Figure 5 shows the concrete syntax for English by using the RGL. Instead of just concatenating strings, we now use functions to create specific type of words and sentences. The categories are now set to be built in types that exists in the RGL and the functions are now using the RGL in order to create values of the correct type.

The most simple function in this case is \texttt{People}, which shall return a noun (N). A noun can be created by using the \emph{operation}\marginpar{An operation in GF is a function which can be called by linearization functions.} \texttt{mkN}. We create a noun which has the singular form \texttt{"person"} and plural form \texttt{"people"}, we will never use the singular form in this grammar, but GF cannot create a noun with only plural form. 

\texttt{Java} creates a noun similarly, except that it only gives \texttt{mkN} one argument. By doing this, GF applies an algorithm in order to find the plural form automatically. This does however only work on regular nouns. \texttt{Know} returns a verb phrase (VP). We use a VP to combine a verb with a noun in order to create a \texttt{Relation}, as seen at lines 16-19. 

How to combine a \texttt{Subject} and a \texttt{Relation} into a \texttt{Question} can be seen in lines 9-14. We first create a relative clause (RCl) by combining a built in constant \texttt{which\_RP} with the verb phrase (\texttt{relation}). There is however no built in operation available to combine a RCl with a noun, so we must create a relative sentence (RS). The RS is then combined with the subject by creating a common noun (CN). In order to only allow translations of plural forms we create a noun phrase with \texttt{aPl\_Det} as determiner.

\begin{figure}[h]
\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm,
               baselinestretch=1,
               fontsize=\footnotesize]{c}
  concrete QuestionsEngRGL of Questions = open SyntaxEng, ParadigmsEng in {
    lincat
      Question = NP ;
      Subject = N ;
      Relation = VP ;
      Object = NP ;

    lin
      MkQuestion subject relation = mkNP aPl_Det 
                                          (mkCN subject 
                                              (mkRS 
                                                  (mkRCl which_RP relation)
                                              )
                                          ) ;
      People = mkN "person" "people" ;
      Know object = mkVP 
                      (mkV2 
                          (mkV "know")
                      ) object ;
      Java = mkNP (mkN "Java") ;
  }
\end{minted}
\caption{English concrete syntax using the RGL}
\end{figure}

\subsection{Generalizing the concrete syntax}

The English concrete syntax which uses the RGL is more complicated than the first version, which only concatenates strings. In order to motivate why one shall use the RGL, this section describes how the concrete syntax can be generalized into an \emph{incomplete concerete syntax} and then be instantiated by two concrete syntaxes, one for English and one for Swedish.