%************************************************
\chapter{Introduction}\label{ch:introduction}
%************************************************
\section{An alternative user interface}
In this thesis we will investigate how we can create a user interface which allows us to execute queries in a query language by expressing instructions in natural language. In other terms, we want to translate from a natural language into a query language. A query language is a computer language which is used to query a database or index. A natural language is a language that humans use to communicate with each other.

\section{Problem description\label{sec:problem-description}}
How can one retrieve information from a computer by writing instructions in a natural language? The inspiration for this thesis came from Facebook graph search\footnote{\url{https://www.facebook.com/about/graphsearch}}, which is a service that allows users to search for entities by asking the server for information in a natural language.

In this project, we have chosen examine how a similar service can be realized. We have limited the project to handle questions that can occur naturally in the intranet of a software development company. We assume that there exists an intranet which consists of a database with information about employees, customers and projects. A typical question to ask in this environment could be

\begin{minted}{text}
Which people know Java?
\end{minted}

The answer would be a list of all employees in the database who have some degree of expertise of the programming language \texttt{Java}. However, when using search engines, expert users do not ask questions as the one above. The simply rely purely on keywords. The following question is more suited for expert users

\begin{minted}{text}
people know java
\end{minted}

How can we create a user interface that is sufficient for both regular- and expert users? And how can we translate these questions into machine readable queries?

\section{A proposed solution}
Query languages require precise syntax, we therefore need precise translation from a natural language into a query language. Since we have a limited scope of questions, we know all questions that can be asked - and we know how their machine readable representation shall look like. We only need a tool which we can use to make the mapping between natural language into query language. A very flexible tool we can use to accomplish this is a multilingual grammar. 

A grammar is a set of structural rules which decide how words can can be created and be combined into clauses and phrases. By expressing \emph{how} words can be combined into a question in one language one can also use the same logic to express how the same question can be produced in another language. A \emph{multilingual} grammar is a special type of grammar which can translate between two or more languages.

Grammars has been used since the 1950's in the field of computer science \cite[p. 4]{ranta:2011}, and they have played a main role in the development of compilers where they are used to translate source code into machine readable instructions.

\section{Grammatical Framework}
Grammatical framework (GF) is a functional programming language for creating grammars for natural languages.\cite[p. 1]{ranta:2011} GF features a strong type system, separate abstract and concrete syntax rules and reusable libraries to facilitate design of grammars. For a reader with a background within compilers, one can easily see that GF is very much based on the theory of programming languages. GF adopts the use of abstract and concrete syntax in the same sense as in compiler theory. 

Abstract syntax is a tree representation which captures the \emph{meaning} of a sentence, and leaves out anything irrelevant. The concrete syntax represents a natural language. It describes how an abstract syntax tree is represented as a string in the natural language.

With both abstract and concrete syntaxes, GF is able to create a \emph{parser} and a \emph{linearizer} for all given concrete languages. The parser translates strings into abstract syntax and the linearizer transaltes abstract syntax trees into string representations for a specified concrete syntax. In addition, GF can also derive a \emph{generator} for the abstract syntax. The generator can create all possible abstract syntax trees.

Because GF separates abstract and concrete syntax, one can easily add a new concrete syntax (natural language) to an existing abstract syntax. This advantage also makes it easy to translate between many languages.

\subsection{A simple example}
The following section presents an example of how GF can be used to create a grammar that can generate and translate the sentence \emph{which people know Java?} into Apache Solr query language and vice verca.\marginpar{Apache Solr is a search platform based on Apache Lucene. We will explain more about Solr query language later in the thesis.}

\subsubsection*{Abstract syntax}
To model the meaning of sentences, GF adopts the use of functions and \emph{categories}. A category (\emph{cat}) in GF is the same as a data type. We start by listing the categories we need. We then define how our data types can take on values. This is achieved by using functions. The functions in an abstract syntax are not implemented, we can therefore only see the function declarations. The purpose for this is to allow the concrete syntaxes to choose how to represent the semantics. Two concrete syntaxes can therefore implement the same semantics differently.

We define a function \texttt{Java : Object} which means that \texttt{Java} is a constant \marginpar{A function without arguments is called a constant in functional programming languages.} and returns a value of type \texttt{Object}. \texttt{Know} takes one argument of the type \texttt{Object} and returns a value of type \texttt{Relation}.

A question can be created by obtaining a value of the type \texttt{Question}. Only \texttt{MkQuestion} returns the desired type and it takes two arguments, one of type \texttt{Subject} the other of type \texttt{Relation}.

\begin{figure}[h]
\begin{code}
abstract Questions = { 
  flags startcat = Question; 
  cat
    Question ; -- A question
    Subject ;  -- The subject of a question
    Relation ; -- A verb phrase
    Object ;   -- an object

  fun		 	  
    MkQuestion : Subject -> Relation -> Question ;
    People : Subject ;
    Know : Object -> Relation ;
    Java : Object ; 
}
\end{code}
\caption{Abstract syntax\label{fig:abstract-syntax}}
\end{figure}

We can now use this abstract syntax to create an abstract syntax tree as seen in \autoref{fig:ast}

\begin{figure}[h]
\begin{plaintext}
MkQuestion People (Know Java)
\end{plaintext}
\caption{Abstract syntax tree\label{fig:ast}}
\end{figure}

\subsubsection*{Concrete syntax}

We are now going to implement the function declarations we just defined in the abstract syntax. This implementation makes it possible to linearize abstract syntax trees into concrete syntax. We will start by defining the concrete syntax for English.

\subsubsection*{English concrete syntax}

\autoref{fig:english-concr} shows the implementation of the concrete syntax for English. Categories are linearized by the keyword \emph{lincat}. Here we assign all categories to be strings. The functions are linearized by using the keyword \emph{lin}. We linearize \texttt{Java} by returning the string \texttt{"Java"}, as it is a constant function. Analogously, \texttt{"people"} is returned by \texttt{People}. The function \texttt{Know} takes one parameter. This parameter is appended on the string \texttt{"know"}. Finally, \texttt{MkQuestion} takes two arguments, where \texttt{subject} is prepended and \texttt{relation} is appended on \texttt{"who"}. One can easily see how these functions can be used to construct the sentence \emph{people who know Java}. This sentence is different from the previously discussed question \emph{which people know Java?} The reason why we chose to model the former is because we find that it is more natural tell the computer what we want rather than ask it politely.

\newenvironment{myfont}{\myfont}{\par}

\begin{figure}[h]
\begin{code}
concrete QuestionsEng of Questions = {
  lincat
    Question = Str ;
    Subject = Str ;
    Relation = Str ;
    Object = Str ;
  lin
    MkQuestion subject relation = subject ++ "who" ++ relation ;
    People = "people" ;
    Know object = "know" ++ object ;
    Java = "Java" ;
}
\end{code}
\caption{English concrete syntax\label{fig:english-concr}}
\end{figure}

\subsubsection*{Solr concrete syntax}

The final step in this example is to linearize abstract syntax into Solr concrete syntax.
  As \autoref{fig:solr-concr} shows, the categories are strings as in English. The function linearizations are however
  different. \texttt{People} returns 
  \texttt{"object\_type : Person"}, we assume that 
  the Solr-schema has a field with the name \texttt{object\_type} which represents 
  which type a document is. Similarly, we make another assumption about \texttt{Know}. \texttt{MkQuestion} is also implemented differently, here we can see that the result is going to be a query string\footnote{\url{http://en.wikipedia.org/wiki/Query\_string}} by looking at the first part \texttt{"q="} which is prepended on the subject. We then append \texttt{"AND"} together with \texttt{relation} in order to create a valid Solr query.

\begin{figure}[h]
\begin{code}
concrete QuestionsSolr of Questions = {
    lincat
      Question = Str ;
      Subject = Str ;
      Relation = Str ;
      Object = Str ;

    lin
      MkQuestion subject relation = "q=" ++ subject ++ "AND" ++ relation ;
      People = "object_type : Person" ;
      Know object = "expertise : " ++ object ;
      Java = "Java" ;
}
\end{code}
\caption{Solr concrete syntax\label{fig:solr-concr}}
\end{figure}

\pagebreak

\subsubsection*{Translation}

In order to make any translations, we need to use the GF runtime system. The  runtime system we will use in this section is the shell application, which allows us to load our GF source code and use parsers, linearizers and generators. In addition to the shell application, there also exists programming libraries for GF in C, Haskell and Java. These libraries can be used to build a translation application which not requires the user to have GF installed.

\begin{figure}[H]
\begin{terminal}
$ gf QuestionsEng.gf QuestionsSwe.gf 
                                
       *  *  *              
    *           *           
  *               *         
 *                          
 *                          
 *        * * * * * *       
 *        *         *       
  *       * * * *  *        
    *     *      *          
       *  *  *              
                            
This is GF version 3.5.12-darcs. 
No detailed version info available
Built on linux/x86_64 with ghc-7.6, flags: interrupt server
License: see help -license.   
Bug reports: http://code.google.com/p/grammatical-framework/issues/list
 - compiling Questions.gf...   write file Questions.gfo
- compiling QuestionsEng.gf...   write file QuestionsEng.gfo
- compiling QuestionsSolr.gf...   write file QuestionsSolr.gfo
linking ... OK
 Languages: QuestionsEng QuestionsSolr
Questions> 
\end{terminal}
%$ <- Texmaker sux at syntax highlighting

\caption{GF shell prompt\label{fig:gf-shell}}
\end{figure}

A string can be parsed into an abstract syntax tree.

\begin{figure}[H]
\begin{terminal}
Questions> parse -lang=QuestionsEng "people who know Java"
MkQuestion People (Know Java)
\end{terminal}

\caption{Parse a string\label{fig:parse-a-string}}
\end{figure}

Abstract syntax trees can be linearized into concrete syntaxes, here we linearize one abstact syntax tree into all known concrete syntaxes.

\begin{figure}[H]
\begin{terminal}
Questions> linearize MkQuestion People (Know Java)
people who know Java
q= object_type : Person AND expertise : Java
\end{terminal}

\caption{Linearize an abstract syntax tree\label{fig:linearization}}
\end{figure}

Finally, a string can be translated from one concrete syntax into another. Here we translate from \texttt{QuestionsEng} into \texttt{QuestionsSolr}. We use a \emph{pipeline}\footnote{\url{http://en.wikipedia.org/wiki/Pipeline_(Unix)}} to pass the result of the parsing as an argument to the linearizing function. Note how we use \texttt{p} instead of \texttt{parse} and \texttt{l} instead of \texttt{linearize}. They are just shorthands of their longer representations.

\begin{figure}[H]
\begin{terminal}
Questions> p -lang=QuestionsEng "people who know Java" | l -lang=QuestionsSolr
q= object_type : Person AND expertise : Java
\end{terminal}
\caption{Translate between concrete syntaxes\label{fig:translation-concr}}
\end{figure}


\section{GF resource grammar library}

The previous example is fairly easy to understand, but it is also very small. As a grammar grows to support translation of more sentences, the complexity grows as well. GF has the power to make distinctions between singular and plural forms, genders, tenses and anteriors. However, in order to correctly develop a grammar to translate these sentences one needs to have knowledge of linguistics. It is also very time consuming to implement basic morphologies over and over again. Instead, one can use GF resource grammar library (RGL). The RGL contains at the time of writing grammars for 29 natural languages. These grammars includes categories and functions which can be used to represent all kinds of different words and sentences. A developer needs therefore only knowledge of her \emph{domain} and do not need to worry about linguistic problems. By domain, we mean specific words which may have special grammatical rules, e.g. fish in English which is the same in singular as in plural form.

\subsection{Example usage of RGL in a grammar}

In this section, we will present how the previous concrete syntax for English can be implemented by using the RGL. We will also show how this grammar can be further generalized into an incomplete concete syntax which can be used by both English and Swedish.

\autoref{fig:english-RGL} shows the concrete syntax for English by using the RGL. Instead of just concatenating strings, we now use functions to create specific type of words and sentences. The categories are now set to be built in types that exists in the RGL and the functions are now using the RGL in order to create values of the correct types.

The most simple function in this case is \texttt{People}, which shall return a noun (N). A noun can be created by using the \emph{operation}\marginpar{An operation in GF is a function which can be called by linearization functions.} \texttt{mkN}. We create a noun which has the singular form \texttt{"person"} and plural form \texttt{"people"}, we will never use the singular form in this grammar, but GF cannot create a noun with only plural form. 

\texttt{Java} creates a noun similarly, except that it only gives \texttt{mkN} one argument. By doing this, GF applies an algorithm in order to find the plural form automatically. This does however only work on regular nouns. \texttt{Know} returns a verb phrase (VP). We use a VP to combine a verb with a noun in order to create a \texttt{Relation}, as seen in lines 16-19. 

How to combine a \texttt{Subject} and a \texttt{Relation} into a \texttt{Question} can be seen in lines 9-14. We first create a relative clause (RCl) by combining a built in constant \texttt{which\_RP} with the verb phrase (\texttt{relation}). There is however no built in operation available to combine a RCl with a noun, so we must create a relative sentence (RS). The RS is then combined with the subject by creating a common noun (CN). In order to only allow translations of plural forms we create a noun phrase with \texttt{aPl\_Det} as determiner.

\begin{figure}[h]
\begin{code}
concrete QuestionsEng of Questions = open SyntaxEng, ParadigmsEng in {
  lincat
    Question = NP ;
    Subject = N ;
    Relation = VP ;
    Object = NP ;

  lin
    MkQuestion subject relation = mkNP aPl_Det 
                                        (mkCN subject 
                                            (mkRS 
                                                (mkRCl which_RP relation)
                                            )
                                        ) ;
    People = mkN "person" "people" ;
    Know object = mkVP 
                    (mkV2 
                        (mkV "know")
                    ) object ;
    Java = mkNP (mkN "Java") ;
}
\end{code}
\caption{English concrete syntax using the RGL\label{fig:english-RGL}}
\end{figure}

\subsection{Generalizing the concrete syntax}

The English concrete syntax which uses the RGL is more complicated than the first version, which only concatenates strings. In order to motivate why one shall use the RGL, this section describes how the concrete syntax can be generalized into an \emph{incomplete concerete syntax} and then be instantiated by two concrete syntaxes, one for English and one for Swedish.

\subsubsection*{An incomplete concrete syntax}

As we already have designed the concrete syntax for English, we can fairly easy convert it to a generalised version. The incomplete concrete syntax can be seen in \autoref{fig:incomplete-concrete-syntax}. We no longer have any strings defined, as we want to keep the syntax generalised. Constant operations are used in place of strings, and they are imported from the lexicon interface  \texttt{LexQuestions}.

\begin{figure}[h]
\begin{code}
incomplete concrete QuestionsI of Questions = open Syntax, LexQuestions in {
    lincat
      Question = NP ;
      Subject = N ;
      Relation = VP ;
      Object = NP ;

    lin
      MkQuestion subject relation = mkNP aPl_Det 
                                        (mkCN subject 
                                            (mkRS 
                                                (mkRCl which_RP relation)
                                            )
                                        ) ;
      People = person_N ;
      Know object = mkVP know_V2 object ;
      Java = java_NP ;
}
\end{code}
\caption{Incomplete concrete syntax\label{fig:incomplete-concrete-syntax}}
\end{figure}

\texttt{LexQuestions} is an \emph{interface}, which means that it only provides declarations. \autoref{fig:lexicon-interface} shows that we have one operation declaration for each word we want to use in the concrete syntax. Because we do not implement the operations, it is possible to create multiple instances of the lexicon where each one can implement the lexicon differently.

\begin{figure}[H]
\begin{code}
interface LexQuestions = open Syntax in {
   oper
     person_N : N ;
     know_V2 : V2 ;
     java_NP : NP ;
}
\end{code}
\caption{Lexicon interface\label{fig:lexicon-interface}}
\end{figure}

\autoref{fig:english-lexicon} shows how the operations defined in \texttt{LexQuestions} are implemented in \texttt{LexQuestionsEng}, we represent the words in the same  way as in the old version of the concrete syntax for English.

\begin{figure}[H]
\begin{code}
instance LexQuestionsEng of LexQuestions = open SyntaxEng, ParadigmsEng in {
    oper
      person_N = mkN "person" "people" ;
      know_V2 = mkV2 (mkV "know") ;	  
      java_NP = mkNP (mkN "Java");
}
\end{code}
\caption{Lexicon instantiation of English \label{fig:english-lexicon}}
\end{figure}

\autoref{fig:swedish-lexicon} shows another instance of \texttt{LexQuestions}, the lexicon for Swedish.

\begin{figure}[H]
\begin{code}
instance LexQuestionsSwe of LexQuestions = open SyntaxSwe, ParadigmsSwe in {
    oper
      person_N = mkN "person" "personer" ;
      know_V2 = mkV2 (mkV "kunna" "kan" "kunna" "kunde" "kunnat" "kunna") ;	  
      java_NP = mkNP (mkN "Java");
}
\end{code}
\caption{Lexicon instantiation of Swedish\label{fig:swedish-lexicon}}
\end{figure}

We are now ready to instantiate the incomplete concrete syntax. The code below describes how \texttt{QuestionsI} is instantiated as \texttt{QuestionsEng}. Note how we override \texttt{Syntax} with \texttt{SyntaxEng} and \texttt{LexQuestions} with \texttt{LexQuestionsEng}.

\begin{figure}[H]
\begin{code}
concrete QuestionsEng of Questions = QuestionsI with 
                                             (Syntax = SyntaxEng), 
                                             (LexQuestions = LexQuestionsEng) 
                                             ** open ParadigmsEng in {}
\end{code}
\caption{English instantiation of the incomplete concrete syntax}
\end{figure}

Analogously, we create an instance for Swedish concrete syntax by instantiating \texttt{QuestionsI} and overriding with different files.

\begin{figure}[H]
\begin{code}
concrete QuestionsSwe of Questions = QuestionsI with 
                                             (Syntax = SyntaxSwe), 
                                             (LexQuestions = LexQuestionsSwe) 
                                             ** open ParadigmsSwe in {}
\end{code}
\caption{Swedish instantiation of the incomplete concrete syntax}
\end{figure}

If we load the GF-shell with \texttt{QuestionsEng.gf} and \texttt{QuestionsSwe.gf} we can make the following translation from English to Swedish.

\begin{figure}[H]
\begin{code}
Questions> p -lang=QuestionsEng "people who know Java" | l -lang=QuestionsSwe
personer som kan Java

personer som kan Java

personer som kan Java

\end{code}
\caption{Swedish instantiation of the incomplete concrete syntax}
\end{figure}

\todo{Why we get three results is unknown at the moment.} Whats really interesting is that we can translate questions formulated in English and Swedish into Solr-syntax.