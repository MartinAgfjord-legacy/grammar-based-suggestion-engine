%************************************************
\chapter{Introduction}\label{ch:introduction}
%************************************************
\section{An alternative user interface}
In this thesis we will investigate how we can create a user interface which allows us to execute queries in a query language by expressing instructions in natural language. In other terms, we want to translate from a natural language into a query language. A query language is a computer language which is used to query a database or index. A natural language is a language that humans use to communicate with each other.

\section{Problem description\label{sec:problem-description}}
How can one retrieve information from a computer by writing instructions in a natural language? The inspiration for this thesis came from Facebook graph search\footnote{\url{https://www.facebook.com/about/graphsearch}}, which is a service that allows users to search for entities by asking the server for information in a natural language.

In this project, we have chosen examine how a similar service can be realized. We have limited the project to handle instructions that can occur naturally in the intranet of a software development company. We assume that there exists an intranet which consists of a database with information about employees, customers and projects. A typical instruction in this environment could be

\begin{minted}{text}
people who know Java
\end{minted}

The answer would be a list of all employees in the database who have some degree of expertise of the programming language \texttt{Java}. However, when using search engines, expert users do not use instructions as the one above. The simply rely purely on keywords \cite{mayer:2007}. The following instruction is more suited for expert users

\begin{minted}{text}
people know java
\end{minted}

How can we create a user interface that is sufficient for both regular- and expert users? And how can we translate these instructions into machine readable queries?

\section{A proposed solution}
Query languages require precise syntax, we therefore need precise translation from a natural language into a query language. Since we have a limited scope of instructions, we know all instructions that the program shall support and we know how their machine readable representation shall look like. We only need a tool which we can use to make the mapping between natural language into query language. A very flexible tool we can use to accomplish this is a multilingual grammar. 

A grammar is a set of structural rules which decide how words can can be created and be combined into clauses and phrases. By expressing how words can be combined into an instruction in one language one can also use the same logic to express how the same instruction can be produced in another language. A \emph{multilingual} grammar is a special type of grammar which can translate between two or more languages.

Grammars has been used since the 1950's in the field of computer science \cite[p. 4]{ranta:2011}, and they have played a main role in the development of compilers where they are used to translate source code into machine readable instructions.

\section{Related work}
This section presents two important projects that this project has been based on.

\hiddensubsection{Facebook graph search}
\autoref{sec:problem-description} describes that we want to build an application similar to Facebook graph search, which is a semantic search engine. Like most search engines, Facebook graph search takes its input as a string by using a text field. Whats special with this search engine is that it is built for extracting the semantics behind a search in order to construct machine readable instructions\marginpar{Machine readable instructions is something that can be executed by a CPU.}. More specifically, by combining natural language words and entities into a natural language phrase, Facebook graph search can translate the phrase into instructions that a machine to understand.

The natural language that can be understood by Facebook Graph Search is represented by a weighted context free grammar (WCFG) \cite{li:2013}. The grammar consists of a set of production rules which is used to extract semantic a parse tree from a natural language sentence. This parse tree represent the \emph{meaning} of the sentence in a semantic way. This tree can be sent to Unicorn, which is a software for retrieving information from Facebook's social graph.

\subsubsection{Entity recognition}
Facebook's grammar also supports entity recognition, which means that the grammar tries to find the suitable \emph{type} of a word if it thinks that it represents an object in the social graph. For example, if the user types \emph{people who live in San Fransisco} then the grammar can with high confidence express that \emph{San Fransisco} is an object of the type \emph{Location}. This is achieved by using n-gram based language models in order to obtain the type with most probability.

\subsubsection{Lexical analysis}
Synonyms are supported by the grammar. Synonyms could be words or sentences. For example the sentence \emph{people who like surfing} has the synonyms \emph{people who surf} and \emph{surfers}. They represent the same semantics.
\newline
\newline
Since computers normally only accept perfectly correct input when dealing with machine instructions, Facebook has added support of grammatically incorrect sentences to the grammar. It can therefore map the sentence \emph{people who works at facebook‚Äù} into \emph{people who work at Facebook}.

\hiddensubsection{Grammatical Framework}
As described previously, Facebook graph search adopts a grammar to achieve translation from a natural language to a machine language. The development of a grammar is far from straight forward and like most programmers, this project has not focused on reinventing the wheel and instead using the technology that is available. We will therefore in this section describe Grammatical Framework (GF), which is an open source functional programming language for creating grammars that can interpret natural languages \cite[p. 1]{ranta:2011}. GF features a strong type system, separate abstract and concrete syntax rules and reusable libraries to facilitate design of grammars. For a reader with a background within compilers, one can see that GF is very much based on the theory of programming languages as they also make use of abstract- and concrete syntaxes\cite[pp. 69-70]{Aho:1986:CPT:6448}.

Abstract syntax is a tree representation which captures the \emph{meaning} of a sentence, and leaves out anything irrelevant. The concrete syntax represents a natural language. It describes how an abstract syntax tree is represented as a string in the natural language.

With both abstract and concrete syntaxes, GF is able to create a \emph{parser} and a \emph{linearizer} for all given concrete languages. The parser translates strings into abstract syntax and the linearizer transaltes abstract syntax trees into string representations for a specified concrete syntax. In addition, GF can also derive a \emph{generator} for the abstract syntax. The generator can create all possible abstract syntax trees.

Because GF separates abstract and concrete syntax, one can easily add a new concrete syntax (a natural language) to an existing abstract syntax. This advantage also makes it easy to translate between many languages.