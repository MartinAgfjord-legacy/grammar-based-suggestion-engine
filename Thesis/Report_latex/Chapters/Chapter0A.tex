%********************************************************************
% Appendix
%*******************************************************
% If problems with the headers: get headings in appendix etc. right
%\markboth{\spacedlowsmallcaps{Appendix}}{\spacedlowsmallcaps{Appendix}}
\chapter{GF runtime systems and libraries}\label{ch:appendix-a}
adasd
\section{GF runtime systems}

While the GF-shell is a powerful tool, it is not very convenient to interact with when programming an application. Luckily, the creators of GF has thought about this and built embeddable runtime systems for a few programming languages \cite[p. 3]{angelov:2011}. These runtime systems makes it possible to interact with a grammar directly through language specific data types. We have chosen to work with the Java-runtime system in this project.

\subsection{Portable Grammar Format}
The GF-shell interacts with grammars by interpreting the GF programming language. This allows us to write our grammars in an simple and convenient syntax. Interpreting the GF programming language directly is however a heavy operation\cite{angelov:2011}[p. 13], especially with larger grammars. This is where the \ac{pgf}\cite{angelov:2011}[p. 14] comes in. PGF is a custom made machine language which is dynamically created by compiling a grammar with GF into a PGF-file. The runtime systems works exclusively with PGF-files.

\subsection{GF libraries}
In order to use the Java-runtime, we first need to generate a few libraries which is used by the runtime system. The Java-runtime system depends on the C-runtime system and a special wrapper between the C- and the Java-runtime. The libraries are platform dependent and at the time of writing, no pre-generated libraries exists. We therefore need to generate the libraries by ourselves. We will start by generating and installing the C-libraries. We will then go through how we can generate the wrapper library.

\subsubsection{Building and installing the C-runtime}
Start by fetching the needed dependencies

\begin{terminal}
sudo apt-get install gcc autoconf libtool
\end{terminal}

Download the latest source code of GF from GitHub.

\begin{terminal}
git clone https://github.com/GrammaticalFramework/GF.git
\end{terminal}

It is also possible to download the project as an archive by visiting the repository url.

You will receive a directory \texttt{GF/}. Change the current working directory to the C-runtime folder.

\begin{terminal}
cd GF/src/runtime/c
\end{terminal}

Generate a configuration file

\begin{terminal}
autoreconf -i
\end{terminal}

Check that all dependencies are met

\begin{terminal}
./configure
\end{terminal}

If there exists a dependency that is not fulfilled, try to install an appropriate package using your package-manager.

Build the program

\begin{terminal}
make
\end{terminal}

Install the libraries you just built

\begin{terminal}
sudo make install
\end{terminal}

Make sure the installed libraries are installed into \texttt{/usr/local/lib}. It is crucial that they exists in that directory in order for the program to work.

\subsection{Building and installing the C to Java wrapper library}
Start by installing the needed dependency

\begin{terminal}
sudo apt-get install g++
\end{terminal}

The wrapper is built by using a script which is executed in Eclipse. This step assumes that you have Eclipse installed with the CDT-plugin. If you don't have Eclipse, you can download it with your package manager, just do not forget to install the CDT-plugin.

Start Eclipse and choose \texttt{File} > \texttt{Import..} in the menu. Choose \texttt{Import Existing Projects into Workspace} and click on the \texttt{Next} button. Select \texttt{Browse...} and navigate to the location where you downloaded GF from GitHub and press enter. Uncheck everything except \texttt{jpgf} and click on \texttt{Finish}. You have now imported the project which can build the Java-runtime system. 

Unfortunately, the build-configuration for the jpgf-project is not complete at time of writing. We therefore need to make additional adjustments in order to build the project.

Right-click on the project and choose \texttt{Properties}. Expand the \texttt{C/C++ Build} menu, click on \texttt{Settings}. Click on \texttt{Includes} which is located below \texttt{GCC C Compiler}. You will see one directory listed in the textbox. You need to check that this directory exists. If not, change it to the correct one. For instance, this tutorial was written using Debian 7 amd64 with Oracle Java 8, hence the correct directory is

\begin{terminal}
/usr/lib/jvm/java-8-oracle/include
\end{terminal}

In addition, one more directory is also needed by the project to build properly.

\begin{terminal}
/usr/lib/jvm/java-8-oracle/include/linux
\end{terminal}

The project also needs another flag in order to build properly. In the \texttt{Properties}-window, click on \texttt{Miscellaneous} below \texttt{GCC C Compiler}. Add \texttt{-fPIC} to the text field next to \texttt{Other flags}. Click on \texttt{Ok} to save the settings.

You can now build the project by choosing \texttt{Project} > \texttt{Build Project} in the menu. If everything went well you shall have generated a file \texttt{libjpgf.so} in \texttt{Release (posix)/} . You can check that the dependencies of \texttt{libjpgf.so} is fulfilled (i.e. it finds the C-runtime) by executing the following in a terminal

\begin{terminal}
ldd libjpgf.so
\end{terminal}

If you cannot see \texttt{'not found'} anywhere in the results, all dependencies are met. However if the C-runtime libraries are missing then \texttt{LD\_LIBRARY\_PATH} is probably not set. This is achieved by executing the following in the terminal:

\begin{terminal}
export LD_LIBRARY_PATH=/usr/local/lib
\end{terminal}

This is only a one time setting and the variable will not exist for the next terminal session. This is however not a problem, since the libraries will be used by Apache Tomcat which will set the variable at startup.

Finish the tutorial by moving the wrapper library to the correct location.

\begin{terminal}
mv libjpgf.so /usr/local/lib
\end{terminal}

\subsection{Using the Java-runtime}
This application can be executed by using any application server that supports \texttt{WAR}-files. The \texttt{WAR}-file in this project is built using Maven, which also can upload the file to an instance of the application server Tomcat. This method is very convenient since it automates a lot work. The following section describes how to install and configure Tomcat and Maven to work with this project.

Download and install Tomcat 8 and Maven (here by using aptitude package-manager).

\begin{terminal}
$ sudo apt-get install tomcat8 tomcat8-admin maven
\end{terminal}
%$

Tomcat requires an uploader to have the correct permissions.
\newline
Edit \texttt{/etc/tomcat8/tomcat-users.xml} and add the following:

\begin{terminal}
/etc/tomcat8/tomcat-users.xml
------------------------------------------------
<tomcat-users>
  <role rolename="manager-gui"/>
  <role rolename="manager-script"/>
  <user username="admin" password="secr3t" roles="manager-gui,manager-script"/>
</tomcat-users>
\end{terminal}

As the application will use the generated wrapper library \texttt{libjpgf.so}, we need to make a proper reference to this library and its dependencies (the C-libraries). This is achieved by creating a new file \texttt{setenv.sh} in the directory \texttt{/usr/share/tomcat8/bin/}, the location of this directory can differ on different Linux-distributions. The directory shall contain the file \texttt{catalina.sh}, so a search on the file should show the correct directory.

Create the file \texttt{setenv.sh} and add the following 

\begin{terminal}
/usr/share/tomcat8/bin/setenv.sh
------------------------------------------------
#!/bin/sh
export LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH
\end{terminal}
%$

Restart Tomcat for the changes to take effect.

\begin{terminal}
$ sudo service tomcat8 restart
\end{terminal}
%$

The next thing we would like to do is to allow Maven to upload applications to Tomcat. As Tomcat now has an admin user with a password, we can use this to setup a server definition in Maven. 
\newline
Add the following to \texttt{/etc/maven/settings.xml}

\begin{terminal}
/etc/maven/settings.xml
------------------------------------------------
<servers>
 <server>
    <id>localTomcatServer</id>
    <username>admin</username>
    <password>secr3t</password>
  </server>
</servers>
\end{terminal}

The field \texttt{id} is used by the application to define that it shall be uploaded to the server we just specified.

The project can now be uploaded to tomcat by executing the following.

\begin{terminal}
$ cd <project_directory>/nlparser
$ mvn tomcat7:deploy
\end{terminal}
%$

The application shall now be accessible through the URL
\newline
 \texttt{http://localhost:8080/nlparser}.