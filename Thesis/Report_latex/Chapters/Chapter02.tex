%************************************************
\chapter{Application development}\label{ch:application-overview}
%************************************************

\section{Requirements specification}

\subsection{Generation of mock data}
As described in \autoref{sec:problem-description}, we want to develop an application which can translate natural language questions that refers to entities in a database or index owned by a software development company. This project has been made with strong collaboration with Findwise, a company with focus on search driven solutions. Findwise has an index with information about employees, projects and customers, however, it is not possible to use their information because it is confidential and cannot be published in a master thesis. A different approach to get hold of relevant data is to generate mock data that is inspired by Findwise's data model. Mock data in this project is simply generated data from files that can be used to simulate a real world example application.

\subsection{Grammar development}
The grammar in \autoref{sec:simple-example} can only translate the question \texttt{people who know Java} in English and Swedish into Solr query language. The grammar needs to be extended to handle \emph{any} programming language that exists in the mock data, not only \texttt{Java}. In addition, it also needs to support other questions involving not only people, but customers and projects.

\subsection{Suggestions}\label{sec:suggestions}
If a user has no idea of which questions the application can translate, how can she use the application? GF has the power to suggest valid words of an incomplete sentence by using incremental parsing. \cite{angelov09:incremental-parser}. This means that even though a user do not know what to type, the application can suggest valid words to use. If the user chooses to add one of those words, the suggestion engine can show a new list of words that will match the new partial sentence.

However, this method does not support the use of only keywords, since one cannot start a sentence with for example the word \texttt{Java}. It it also inflexible since it does not support the use of words outside the grammar, e.g. \texttt{all people who know Java}\marginpar{The parser would not be able to parse the word \emph{all}}.

\todo{One solution to this problem is ; write about how to use chunks and stuff}

This thesis takes a different approach on a suggestion engine. Instead of suggesting one word at a time, one can suggest a whole sentence based on what the user has typed so far. This is achieved by generating all possible sentences that the application can translate and indexing them in Apache Solr. This makes it very easy to search on matching sentences, we also gain powerful techniques such as approximate string matching. 
\newline
\newline
By using this approach, if a user types a sentence in the application, it will search in the index on instructions related to the string and retrieve the most relevant instructions.

As the suggestion engine uses a search platform, it is possible to type anything and get suggestions, even only keywords like \texttt{'people java'} will suggest instructions that can be formulated with these two words.

\subsection{Runtime environment}
The chosen programming language for this project is Java. The main reason is because it is Findwise's primary programming language. It is also very well known among many companies in the world.
Many professional Java-developers adopts a specific development platform, \ac{javaee}. This platform provides many libraries that can be scaled to work in an enterprise environment. This project also adopts Java EE.

\subsubsection*{Handling dependencies}
A typical Java EE project make use of several libraries, in computer science terms we say that a project can have other libraries as \emph{dependencies}. It is not unusual that these libraries also have their own dependencies. Larger projects can therefore have a lot of dependencies, so many that it becomes hard to keep track of them. This project make use of an open source tool called Apache Maven to handle dependencies. One simply list all libraries the project shall have access to, then Maven will automatically fetch them and their dependencies. This also makes the application more flexible, as it do not have to include the needed libraries in the application.

\subsubsection*{Input and output presentation}
Besides handling translation and suggestions, the application also needs to handle input and present its results in some way. This application takes input and presents output by using a web gui\footnote{\url{http://en.wikipedia.org/wiki/Graphical_user_interface}}.

To summarize, this application is a web application built in Java EE and uses Apache Maven for library management.

\subsubsection{Running the application}
Web applications built in Java are usually has the WAR file format. It a special JAR-file which includes classes, dependencies and web pages. This project uses an open source web server called Apache Tomcat to host a web application by exporting our application as a WAR-file. Apache Tomcat will make the application available by using HTTP-requests and spawn a new thread for each request.

Details about the runtime environment can be found in \autoref{ch:appendix-a}.

\section{Generation of mock data}
This section describes how the data used by the application is generated. In order to generate data, one must know what to generate. In this context, this means that 

\section{Grammar development}
This section continues the work on the grammar introduced in \autoref{sec:simple-example}.

\subsection{Supported instructions}
The example grammar could only translate one instruction. This instruction in English is \emph{people who know Java}. It is easy to extend this grammar to support more programming languages, for example, to support \emph{Python} one can add a function \texttt{Python : Object} in the abstract syntax and implement it as \texttt{Python = "python"} in the concrete syntaxes. However, this approach makes the grammar inflexible because we need to extend the grammar every time we want to add a new programming language.

\subsection{Names}
Defining a new function for each programming language is not a good idea, it forces us to update the grammar every time we want it to support a new programming language. A better solution would be to make one function that could be used by any programming language.

One intuitive approach to solve this problem is to create a function \texttt{MkObject : String -> Object}. The implementation for this function would be 
\begin{figure}[H]
\begin{code}
-- Abstract syntax
MkObject : String -> Object ;
-- RGL implementation
MkObject str = mkNP (mkPN str.s) ; -- PN = Proper Name
-- Solr implementation
MkObject str = str.s ;
\end{code}
\caption{Intuitive approach on names}
\end{figure}

The GF-code compiles, and the parsing and linearization by using Solr query language works. Unfortunately, this approach does not work with the RGL. GF cannot create a proper name by using an arbitrary string. \todo{Why?}

Fortunately, there exists a built in category which can be used for exactly these situations. We use the category \texttt{Symb}, along with the function \texttt{MkSymb : String -> Symb} to represent arbitrary strings. We can then use the function \texttt{SymbPN} to create a proper name and finally create a noun phrase.
\begin{figure}[H]
\begin{code}
-- Abstract syntax
MkObject : Symb -> Object ;
-- RGL implementation
MkObject symb = mkNP (SymbPN symb) ; -- PN = Proper Name
-- Solr implementation
MkObject symb = symb.s ; -- Symb has the type { s : Str }
\end{code}
\caption{Working approach on names}
\end{figure}

By using this solution, we can translate the sentence \emph{people who know foo}, where \emph{foo} can be anything.

\subsection{More questions}
We have only covered translation of one sentence in the application so far. \autoref{fig:suppported-sentences} shows all sentences that the end application supports.
\begin{figure}[H]
\begin{terminal}
English                        Solr query language
people who know Java           q= object_type : Person AND KNOWS : Java
people who work in London      q= object_type : Person AND WORKS_IN : London
people who work with Unicef    q= object_type : Person AND WORKS_WITH : Unicef
customers who use Solr         q= object_type : Customer AND USES : Solr
projects who use Solr          q= object_type : Project AND USES : Solr
\end{terminal}
\caption{All sentences supported by the application\label{fig:suppported-sentences}}
\end{figure}

Two more cases has been added to instructions regarding \emph{people}. In addition, two new type of instructions has been added, translations about customers and projects. Note that \autoref{fig:suppported-sentences} only shows instances of instructions. As described in the previous section, the grammar uses names that can take on any string for specific parts of the sentences. This means that the words \emph{Java}, \emph{London}, \emph{Unicef} and \emph{Solr} can be exchanged into anything.

\subsection{Extending the grammar}
It is not trivial to extend the grammar to support the instructions described in the previous section.. One has to take into account that it shall not be possible to translate invalid instructions like \emph{projects who work in London}.

\subsubsection{Abstract syntax}

The first step towards a solution to this problem is to modify the abstract syntax. We begin by removing the category \texttt{Subject} and replacing it with three new categories: \texttt{Internal}, \texttt{External} and \texttt{Resource}. The function \texttt{People} will return a value of the type \texttt{Internal} and \texttt{Customer} and \texttt{Project} will return values of the types \texttt{External} and \texttt{Resource} respectively.

\begin{figure}[H]
\begin{code}
-- Instructions.gf
cat
  Internal ;
  External ;
  Resource ;
fun
  People   : Internal ;
  Customer : External ;
  Project  : Resource ;
\end{code}
\caption{Abstract syntax with new categories and functions for subjects}
\end{figure}

In addition to adding new subject categories, three new categories for relations are also introduced: \texttt{InternalRelation}, \texttt{ExternalRelation} and \texttt{ResourceRelation} (\texttt{Relation} is removed). The idea is to link subject values to the correct relation types. For instance, we link a value of the type \texttt{Internal} with a value of type \texttt{InternalRelation}.

All relation functions are changed to return the correct type. For example, \texttt{Know} is changed to return a value of the type \texttt{InternalRelation}. This means that only \texttt{People} can be used together with \texttt{Know}, as desired. \autoref{fig:newrelations} also shows the new supported relations.

\begin{figure}[H]
\begin{code}
cat
  InternalRelation ;
  ExternalRelation ;
  ResourceRelation ;
fun
  Know     : Object -> InternalRelation ;
  UseExt   : Object -> ExternalRelation ;
  UseRes   : Object -> ResourceRelation ;
  WorkIn   : Object -> InternalRelation ;
  WorkWith : Object -> InternalRelation ;
\end{code}
\caption{Abstract syntax with new categories and functions for relations \label{fig:newrelations}}
\end{figure}

The last thing to modify is how subjects and relations are combined. The function \texttt{MkInstruction} is replaced by three new functions: \texttt{InstrucInternal}, \texttt{InstrucExternal} and \texttt{InstrucResource}. However, as we do not need to make any distinction between different type of instructions at this level, all three functions returns a value of the type \texttt{Instruction}.

\begin{figure}[H]
\begin{code}
cat
  Instruction ;
fun
  InstrucInternal : Internal -> InternalRelation -> Instruction ;
  InstrucExternal : External -> ExternalRelation -> Instruction ;
  InstrucResource : Resource -> ResourceRelation -> Instruction ;
\end{code}
\caption{Abstract syntax with new categories and functions for instructions\label{fig:newinstructions}}
\end{figure}

\subsubsection{Concrete syntax for RGL}
As the abstract syntax has changed, the concrete syntaxes has to be modifed as well. This section explains how the generalised concrete syntax which uses the RGL is implemeneted. 

\autoref{fig:rgl-new-categories} shows how the categories has been implemented. The new categories are implemented in the same way as the previous.

\begin{figure}[H]
\begin{code}
lincat
  Instruction = NP ;
  Internal, External, Resource = N ;
  InternalRelation, ExternalRelation, ResourceRelation = VP ;
\end{code}
\caption{RGL concrete syntax with new category implementations\label{fig:rgl-new-categories}}
\end{figure}

The new subject functions are implemented in the same way as \texttt{People}.

\begin{figure}[H]
\begin{code}
lin
  People = person_N ;
  Customer = customer_N ;
  Project = project_N ;
\end{code}
\caption{RGL concrete syntax with new subject implementations\label{fig:rgl-new-subjects}}
\end{figure}

Four new relation functions are added. Line 5-6 in \autoref{fig:rgl-new-relations} shows how we use the verb \texttt{work\_V} together with two prepositions, \texttt{in\_Prep} and \texttt{with\_Prep} in order correctly linearize into \emph{work in foo} and \emph{work with foo} respectively (\emph{foo} is the value of \texttt{object}.

\begin{figure}[H]
\begin{code}
lin
  Know object = mkRS' (mkVP know_V2 object) ;
  UseExt object = mkRS' (mkVP use_V2 object) ;
  UseRes object = mkRS' (mkVP use_V2 object) ;
  WorkIn object = mkRS' (mkVP (mkV2 work_V in_Prep) object) ;
  WorkWith object = mkRS' (mkVP (mkV2 work_V with_Prep) object) ;
\end{code}
\caption{RGL concrete syntax with new relation implementations\label{fig:rgl-new-relations}}
\end{figure}

Subjects and relations are combined as before, but as this solution has three functions instead of one, a new operation \texttt{mkQ} has been defined in order to reuse code.

\begin{figure}[H]
\begin{code}
lin
  InstrucInternal internal relation = mkI internal relation ;
  InstrucExternal external relation = mkI external relation ;
  InstrucResource resource' relation = mkI resource' relation ;

oper
  mkI : N -> RS -> NP = \noun,rs -> mkNP aPl_Det 
                             (mkCN noun rs) ;
\end{code}
\caption{RGL concrete syntax with new instruction implementations\label{fig:rgl-new-instructions}}
\end{figure}

\subsubsection{Concrete syntax for Solr}
This section describes how the concrete syntax for Solr is modified to work with the new abstract syntax.

The new categories are all defined as strings.

\begin{figure}[H]
\begin{code}
lincat
  Instruction = Str ;
  Internal, External, Resource = Str ;
  InternalRelation, ExternalRelation, ResourceRelation = Str ;
  Object = Str ;
\end{code}
\caption{Solr concrete syntax with new implementation of categories\label{fig:solr-categories-impl}}
\end{figure}

Subject types are hard coded into strings. We assume that these strings exists in the Solr index.

\begin{figure}[H]
\begin{code}
lin
  People = "Person" ;
  Customer = "Organization" ;
  Project = "Project" ;
\end{code}
\caption{Solr concrete syntax with new subject implementations\label{fig:solr-function-implementation}}
\end{figure}

We also make an assumption about how the relations are defined in the Solr index. 

\begin{figure}[H]
\begin{code}
lin
  Know obj = "KNOWS" ++ ":" ++ obj ;
  UseExt obj = "USES" ++ ":" ++ obj ;
  UseRes obj = "USES" ++ ":" ++ obj ;
  WorkWith obj = "WORKS_WITH" ++ ":" ++ obj ;
  WorkIn obj = "WORKS_IN" ++ ":" ++ obj ;
\end{code}
\caption{Solr concrete syntax with new relation implementations\label{fig:solr-new-relations}}
\end{figure}

As in the concrete syntax for RGL, also an operation is defined and used by the three functions.

\begin{figure}[H]
\begin{code}
lin
  InstrucInternal internal relation = select internal relation ;
  InstrucExternal external relation = select external relation;
  InstrucResource resource' relation = select resource' relation;

oper
  select : Str -> Str -> Str = \subj,relation -> 
                    "select?q=*:*&wt=json&fq=" ++ "object_type :" 
                    ++ subj ++ "AND" ++ relation ;
\end{code}
\caption{Solr concrete syntax with new instruction implementations\label{fig:solr-new-instructions}}
\end{figure}

\section{Boolean operators}
The grammar is now powerful enough to translate a variety of questions. To make it even more powerful, one could use boolean operators in order to combine relations. For example, an instruction that could be useful is \emph{people who know Java and Python}. Another useful instruction is \emph{people who know Java and work in Gothenburg}. This section explains how the grammar can be extended to support these kind of instructions.

In addition to the previous example with the boolean operator \emph{and}, we will also add support for the boolean operator \emph{or}. We begin by adding functionality to support boolean operators to combine values of the type \texttt{Object}. As seen in \autoref{fig:boolean-abs-obj}, two new functions are defined in the abstract syntax to handle these cases, one for each operator.

\begin{figure}[H]
\begin{code}
lin
  And_O : Object -> Object -> Object ;
  Or_O : Object -> Object -> Object ;
\end{code}
\caption{Abstract syntax for boolean operators and objects\label{fig:boolean-abs-obj}}
\end{figure}

The RGL implementation is shown in \autoref{fig:boolean-rgl-obj}.

\begin{figure}[H]
\begin{code}
lin
  And_O o1 o2 = mkNP and_Conj o1 o2 ;
  Or_O o1 o2 = mkNP or_Conj o1 o2 ;
\end{code}
\caption{RGL concrete syntax for boolean operators and objects\label{fig:boolean-rgl-obj}}
\end{figure}

The Solr implementation is shown in \autoref{fig:boolean-solr-obj}. We add \texttt{AND} or \texttt{OR} between the two objects.

\begin{figure}[H]
\begin{code}
lin
  And_O o1 o2 = "(" ++ o1 ++ "AND" ++ o2 ++ ")" ;
  Or_O o1 o2 = "(" ++ o1 ++ "OR" ++ o2 ++ ")" ;
\end{code}
\caption{Solr concrete syntax for boolean operators and objects\label{fig:boolean-solr-obj}}
\end{figure}

It is now possible to express \emph{people who know Java and Python}. In order to use boolean operators with whole relations like \emph{people who know Java and work in Gothenburg}, the grammar has to be further extended.

We must also take into account that it shall only be possible to combine relationship that are possible to express in the current sentence. Therefore, we need to define the boolean logic three times, as we have three different types of instructions.

\begin{figure}[H]
\begin{code}
lin
  InternalAnd : InternalRelation -> InternalRelation -> InternalRelation ;
  InternalOr : InternalRelation -> InternalRelation -> InternalRelation ;

  ExternalAnd : ExternalRelation -> ExternalRelation -> ExternalRelation ;
  ExternalOr : ExternalRelation -> ExternalRelation -> ExternalRelation ;
 	  
  ResourceAnd : ResourceRelation -> ResourceRelation -> ResourceRelation ;
  ResourceOr : ResourceRelation -> ResourceRelation -> ResourceRelation ;
\end{code}
\caption{Abstract syntax for boolean operators and relations\label{fig:boolean-abstract-relations}}
\end{figure}

Instead of combining noun phrases as in \autoref{fig:boolean-rgl-obj}, here we combine relative sentences in the RGL implementation.

\begin{figure}[H]
\begin{code}
lin
  InternalAnd rs1 rs2 = mkRS and_Conj rs1 rs2 ;
  InternalOr rs1 rs2 = mkRS or_Conj rs1 rs2 ;
	  
  ExternalAnd rs1 rs2 = mkRS and_Conj rs1 rs2 ;
  ExternalAnd rs1 rs2 = mkRS or_Conj rs1 rs2 ;
	  
  ResourceAnd rs1 rs2 = mkRS and_Conj rs1 rs2 ;
  ResourceOr rs1 rs2 = mkRS or_Conj rs1 rs2 ;
\end{code}
\caption{RGL concrete syntax for boolean operators and relations\label{fig:boolean-rgl-relations}}
\end{figure}

The Solr implementation is fairly straight forward, similarly as with values of the type \texttt{Object}, we also add \texttt{AND} or \texttt{OR} between the strings. The only difference is that we do it three times as we have three different subject types.

\begin{figure}[H]
\begin{code}
lin
  InternalAnd s1 s2 = "(" ++ s1 ++ "AND" ++ s2 ++ ")";
  InternalOr s1 s2 = "(" ++ s1 ++ " OR " ++ s2 ++ ")";

  ExternalAnd s1 s2 = "(" ++ s1 ++ "AND" ++ s2 ++ ")";
  ExternalOr s1 s2 = "(" ++ s1 ++ " OR " ++ s2 ++ ")";

  ResourceAnd s1 s2 = "(" ++ s1 ++ "AND" ++ s2 ++ ")";
  ResourceOr s1 s2 = "(" ++ s1 ++ " OR " ++ s2 ++ ")";
\end{code}
\caption{Solr concrete syntax for boolean operators and relations\label{fig:boolean-solr-relations}}
\end{figure}

\section{Suggestion engine}
This section continues where \autoref{sec:suggestions} left off. The suggestion engine shall generate all possible instructions in all natural languages and store them in an Apache Solr index. It is suitable to use the \emph{generator} which GF creates to generate abstract syntax trees and linearize them into the specified concrete languages (English and Swedish in this case).

The generator can be accessed through the GF-shell.  \autoref{fig:gf-shell-generate-trees} shows how the function \texttt{generate\_trees} is executed to generate all trees with the \emph{depth} 4. By depth, we mean the maximum number edges between a leaf and the root element.

\begin{figure}[H]
\begin{terminal}
Instrucs> generate_trees
InstrucExternal Customer (UseExt (MkObject (MkSymb "Foo")))
InstrucInternal People (Know (MkObject (MkSymb "Foo")))
InstrucInternal People (WorkIn (MkObject (MkSymb "Foo")))
InstrucInternal People (WorkWith (MkObject (MkSymb "Foo")))
InstrucResource Project (UseRes (MkObject (MkSymb "Foo")))
\end{terminal}
\caption{\texttt{generate\_trees} is used to create all abstract syntax trees with max depth 4\label{fig:gf-shell-generate-trees}}
\end{figure}

\autoref{fig:gf-shell-generate-trees} shows 5 trees, but there exists many more trees.\marginpar{Actually, there exists infinitely many trees, as we have recursive functions in the abstract syntax.} The reason GF only generates 5 trees is because of the default depth setting is 4. If we increase the depth we will obtain more trees, as it then will include trees containing boolean operators. By increasing the max depth to 5, GF will generate 36 trees. With depth 6, GF will generate 1653 trees.
\newline
\newline
It is often good to visualize trees to understand them better. \autoref{fig:asts-depths} shows two abstract syntax trees, the first one with depth 4 and the second with depth 5. One can easily see that the former has maximum 4 edges between root and leaf, and the latter has 5 edges between root and leaf.

\begin{figure}[H]
\includegraphics[scale=0.6,keepaspectratio,valign=t]{./gfx/depth4}
\includegraphics[scale=0.6,keepaspectratio,valign=t]{./gfx/depth5}
\caption{Visualization of abstract syntax trees with depth 4 and 5\label{fig:asts-depths}}
\end{figure}

\subsection{Populating the Solr index}
It is now time to linearize the generated trees and store them in a Solr index. By doing so, we will be able to search on instructions by using words that exists in the instructions. What we cannot do is to search on names, because the names does not occur in the instructions, instead they only contain a placeholder for a name (\emph{"Foo"}). It will therefore only suggest instructions like \emph{people who know Foo and Foo} which is a useless suggestion.

We want to be able to suggest relevant names, if the user database contains a person which knows Java, then we also want to suggest instructions based on that name. This requirement forces us to change the application once more. 
\newline
\newline
A na{\"i}ve solution would be to fetch all distinct names from the database and create all possible instructions that a user shall be able to express with these names. For an instruction like \emph{people who know Foo or Foo and works in Foo} and if the database contains 10 programming languages and 10 cities we would then have to generate $2*10*10=200$ instructions. This is clearly not suitable, as GF generates 1653 trees (with depth 6).
\newline
\newline
A better approach on the problem is to store all distinct names in a separate index. When a user begins to type an instruction, the application checks each word the user has typed. If a word exists in the name-index, then treat it as a name and replace it with \texttt{Foo}, then query the tree index. Retrieve the results, and change back \texttt{Foo} to the original name. However, as the application do not make any distinction between different type of names, we could end up with suggestions like \emph{people who work in Python}, because \emph{Python} was replaced by \emph{Foo}. Luckily, this problem can be resolved by introducing a distinction between different types of names in the grammar.

This application uses four different kind of names. Programming languages are used together with the \texttt{Know} relation. Organizations are used with the \texttt{Work\_With} relation. Locations are used with the \texttt{Work\_In} relation. Lastly, modules are used with the \texttt{Use} relation. We extend the grammar to support these new name types.

\autoref{fig:abstract-syntax-name-types} shows the new abstract syntax. Line 3 defines new name types. Line 7-10 defines how the names are instantiated. Lines 13-23 defines how names can be combined by using boolean operators. Note how we use the type \texttt{Skill} for programming languages.

\begin{figure}[H]
\begin{code}
cat
  -- Names
  Skill ; Organization ; Location ; Module ;
  
fun
  -- Create unknown names
  MkSkill : Symb -> Skill ;
  MkOrganization : Symb -> Organization ;
  MkModule: Symb -> Module ;
  MkLocation : Symb -> Location ;
  
  -- Boolean operators for Organizations
  And_S : Skill -> Skill -> Skill ;
  Or_S : Skill -> Skill -> Skill ;

  And_O : Organization -> Organization -> Organization ;
  Or_O : Organization -> Organization -> Organization ;

  And_L : Location -> Location -> Location ;
  Or_L : Location -> Location -> Location ;

  And_M : Module -> Module -> Module ;
  Or_M : Module -> Module -> Module ;
\end{code}
\caption{Abstract syntax with new name types\label{fig:abstract-syntax-name-types}}
\end{figure}

The concrete syntax for these new functions are implemented in the same way as the ones we removed (category \texttt{Object} and functions \texttt{MkObject}, \texttt{And\_O} and \texttt{Or\_O}). We have omitted the new concrete syntaxes from the thesis as they do not contribute to anything new.
\newline
\newline
As the grammar has changed, also the abstract syntax trees has changed. The sentence \emph{people who know Java} is now represented by the following abstract syntax tree:
\begin{figure}[H]
\begin{terminal}
cat
  -- Names
  Skill ; Organization ; Location ; Module ;
  
fun
  -- Create unknown names
  MkSkill : Symb -> Skill ;
  MkOrganization : Symb -> Organization ;
  MkModule: Symb -> Module ;
  MkLocation : Symb -> Location ;
  
  -- Boolean operators for Organizations
  And_S : Skill -> Skill -> Skill ;
  Or_S : Skill -> Skill -> Skill ;

  And_O : Organization -> Organization -> Organization ;
  Or_O : Organization -> Organization -> Organization ;

  And_L : Location -> Location -> Location ;
  Or_L : Location -> Location -> Location ;

  And_M : Module -> Module -> Module ;
  Or_M : Module -> Module -> Module ;
\end{terminal}
\caption{Abstract syntax with new name types\label{fig:abstract-syntax-name-types}}
\end{figure}