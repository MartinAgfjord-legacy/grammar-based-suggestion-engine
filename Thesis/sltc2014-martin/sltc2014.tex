\documentclass[10pt, a4paper]{article}
\usepackage{sltc2014}
\usepackage{newclude}

\title{Grammar-based suggestion engine with keyword search}

\name{Martin Agfjord, Krasimir Angelov, Per Fredelius, Svetoslav Marinov} 

\address{University of Gothenburg, Findwise AB\\
               Gothenburg\\ 
               {\tt martin.agfjord@gmail.com, krasimir@chalmers.se}\\ }
          
         
\abstract{An article may include an abstract of 100 to 150 words. If you use an abstract, its heading should be centered using font Times, 10 bold. If not, remove the abstract section.}

\begin{document}

\maketitleabstract

\section{Introduction}
An alternative approach on building a user friendly interface for a database is  natural language translation. This method has been used before by Facebook \cite{li:2013} in their graph search application, which adopts a grammar to translate structured sentences into machine readable syntax. This paper describes how a similar application can be developed by creating a grammar with \emph{Grammatical Framework (GF)} \cite{ranta:2013} and using \emph{Apache Solr} \cite{kuc:2011} to give relevant suggestions of valid sentences based on keywords or a partial sentence.
\newline
\newline
In order to articulate any sentences we assume this application will be used by a software development company which has a Solr index with the entities \emph{Customers, People} and \emph{Projects}. An example of a valid sentence in this environment is \texttt{people who know Java}, which when executed will instruct the Solr index to retrieve all documents where the field \texttt{object\_type} has the value \texttt{person} and the \texttt{KNOWS}-field contains the value \texttt{Java}. 

While translations like this allows the user to express queries in a natural language, it is not very likely that the user will be able to use the system without any knowledge of the translations it support. We will therefore use a suggestion engine which purpose is to help the user to find valid sentences based on partial input.

\section{Grammatical Framework}
GF is an open source development platform for natural languages which is specifically designed for creating natural language grammars. GF adopts the use of abstract and concrete syntax much like compilers do. The abstract syntax represents the \emph{semantics} of a sentence and the concrete syntax represents how the semantics looks like a string in a language. 

An abstract syntax usually consists of unimplemented functions which can be combined to form an abstract syntax tree (AST). A concrete syntax implements the unimplemented functions to represent the semantics as strings. An AST can be \emph{linearized} into a string by executing the functions in a concrete syntax. Conversely, a string can be parsed into an AST by dividing the string into functions.

\section{Defining the grammar in GF}
We define functions to represent \emph{subjects, predicates} and \emph{objects}. In addition, we also define rules which combines these values into sentences. For example, the sentence \texttt{customers who use Solr} is splitted into the AST \texttt{MkInstruction Customer (Use (MkObject "Solr"))} by the grammar. This AST will be linearized into \texttt{select?q=object\_type : Organization AND USES : ( Solr )} by using the concrete syntax for Solr. We make use of arbitrary names in order to let the objects of each sentence take any string.

In addition, we also have functions for boolean operators in the grammar. There are two cases where we allow boolean operators. The first is in between two arbitrary names, e.g. \texttt{Java \textbf{or} Haskell}. The second case is in between two combinations of a predicate and an object, e.g. \texttt{know Java \textbf{and} work in London}. Boolean operators are easily implemented in Solr syntax since it is natural to use them in a query language.

\section{Suggestion Engine}
The grammar can translate sentences from English into Solr query language and offers suggestions of words by using incremental parsing \cite{krasimir}. However, suggestion of words can only be used for the next accepted word of a sentence and can therefore not be used for suggestions on an invalid partial sentence or keywords.

Apache Solr offers functions which approximate how similar a string is to strings stored in a Solr core. It makes therefore sense to use Solr to match a partial sentence or only keywords into natural language sentences defined by our grammar. We generate all defined sentences and store them in a Solr core.

\subsection{Generation of sentences}
GF offers a \emph{generator} which can generate all AST's. We generate all AST's up to a certain limit. The limitation is needed as we have infinitely many AST's because of the recursive boolean functions. Because we use arbitrary strings in our grammar, GF will use  \texttt{"Foo"} in an AST when it expects a name. We will therefore generate AST's like \texttt{MkInstruction People (Know (MkObject "Foo"))} which linearizes into \texttt{people who know Foo}. This linearization would not be very helpful as a suggestion to a user since \texttt{Foo} is not a programming language.

A solution is to replace \texttt{Foo} with a relevant name before presenting the suggestions to a user (we assume all names exists in a separate Solr core). However, as we treat all names as objects, it would be possible for suggest many strange sentences to the user, such as \texttt{people who work in Haskell}.

In order to make distinctions between different names we introduce \emph{name types}. A \texttt{Skill} is a programming language, an \texttt{Organization} is an organization, a \texttt{Location} is a physical location and a \texttt{Module} is an application module. The previous AST now looks like this \texttt{MkInstruction People (Know (MkSkill "Foo"))}. The function \texttt{MkSkill} reveals that the name in this function is of the type \texttt{Skill}. 

The English linearization of the previous AST will however still not contain anything about the type, since the linearization function for \texttt{MkSkill "Foo"} just returns \texttt{Foo}. To preserve the type of each name, we post-process each AST and replace \texttt{"Foo"} with the actual type and an index, in this example \texttt{"Skill0"}.

\subsection{Suggestion retrieval}
 We generate sentences as described in the previous section and store them in a Solr core. This section describes how we take an input from the user and present relevant suggestions based on the input. This method is rather na√Øve and can definitely be better.

 We split an input on words and check if each word is a name by asking the Solr core which contains all names (and their types). If a word is a name, we replace it in the input with its type plus an index. For example, the sentence \texttt{people java} will be changed into \texttt{people Skill0}. This string we now 

\section{Conclusions}

\bibliographystyle{sltc2014}
%\bibliography{sltc2014} 

\include*{bibliography}
\end{document}
